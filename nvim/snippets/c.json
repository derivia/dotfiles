{"free_lines":{"prefix":"free_lines","body":["void free_lines(char **lines, size_t line_count)","{","  for (size_t i = 0; i < line_count; i++) {","    free(lines[i]);","  }","  free(lines);","}"]},"read_string_stdin":{"body":["char *read_string(char separator)","{","  size_t capacity = 10;","  size_t length = 0;","  char *str = malloc(capacity * sizeof(char));","  if (str == NULL) {","    fprintf(stderr, \"Memory allocation failed.\\n\");","    exit(1);","  }","","  int ch;","  while ((ch = getchar()) != EOF && ch != separator && ch != '\\n') {","    str[length++] = ch;","    if (length == capacity) {","      capacity *= 2;","      str = realloc(str, capacity * sizeof(char));","      if (str == NULL) {","        fprintf(stderr, \"Memory reallocation failed.\\n\");","        exit(1);","      }","    }","  }","  str[length] = '\\0';","  return str;","}"],"prefix":"read_string_stdin"},"remove_whitespace":{"prefix":"remove_whitespace","body":["void remove_whitespace(char *str)","{","  char *dst = str;","  while (*str) {","    if (!isspace((unsigned char)*str))","      *dst++ = *str;","    str++;","  }","  *dst = '\\0';","}"]},"caesar_cipher":{"prefix":"caesar_cipher","body":["void caesar_cipher(char *string, int shifts)","{","  shifts = shifts % 26;","  for (int i = 0; string[i] != '\\0'; i++) {","    if (string[i] >= 'a' && string[i] <= 'z') {","      string[i] = 'a' + (string[i] - 'a' + shifts + 26) % 26;","    } else if (string[i] >= 'A' && string[i] <= 'Z') {","      string[i] = 'A' + (string[i] - 'A' + shifts + 26) % 26;","    }","  }","}"]},"remove_character":{"prefix":"remove_character","body":["void remove_character(char *str, char c)","{","  char *dst = str;","  while (*str) {","    if (*str != c)","      *dst++ = *str;","    str++;","  }","  *dst = '\\0';","}"]},"count_words":{"prefix":"count_words","body":["int count_words()","{","  int count = 0;","  int in_word = 0;","  char c;","  while ((c = getchar()) != EOF) {","    if (isspace(c)) {","      if (in_word)","        in_word = 0;","    } else if (!in_word) {","      in_word = 1;","      count++;","    }","  }","  return count;","}"]},"issuffix":{"body":["bool issuffix(char *str1, char *str2)","{","  size_t len1 = strlen(str1);","  size_t len2 = strlen(str2);","  if (len2 > len1) {","    return false;","  }","  return strcmp(str1 + len1 - len2, str2) == 0;","}"],"prefix":"issuffix"},"is_substring":{"prefix":"is_substring","body":["int is_substring(const char *a, const char *b)","{","  return strstr(b, a) != NULL;","}"]},"isprime":{"body":["bool isprime(int number)","{","  if (number <= 1) return false;","  if (number <= 3) return true;","  if (number % 2 == 0 || number % 3 == 0) return false;","  for (int i = 5; i * i <= number; i += 6)","    if (number % i == 0 || number % (i + 2) == 0) return false;","  return true;","}"],"prefix":"isprime"},"libimpexp":{"prefix":"libimpexp","body":["#ifdef _WIN32","#ifdef <LIB>_EXPORTS","#define <LIB>_API \\","  __declspec(dllexport) \/\/ when building the library, export the functions","#else","#define <LIB>_API \\","  __declspec(dllimport) \/\/ when using the library, import the functions","#endif","#else","#define <LIB>_API \\","  __attribute__((visibility(\"default\"))) \/\/ for GCC\/Clang (Linux\/Mac)","#endif"]},"debug":{"prefix":"debug","body":"fprintf(stderr, \"\\033[1;33m[DEBUG]: \\033[0m\\n\");"},"read_lines":{"prefix":"read_lines","body":["char *line = NULL;","size_t len = 0;","size_t read;","while ((read = getline(&line, &len, stdin)) != -1) {","}"]}}