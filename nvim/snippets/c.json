{"is_substring":{"body":["int is_substring(const char *a, const char *b)","{","  return strstr(b, a) != NULL;","}"],"prefix":"is_substring"},"debug":{"body":"fprintf(stderr, \"\\033[1;33m[DEBUG]: \\033[0m\\n\");","prefix":"debug"},"issuffix":{"body":["bool issuffix(char *str1, char *str2)","{","  size_t len1 = strlen(str1);","  size_t len2 = strlen(str2);","  if (len2 > len1) {","    return false;","  }","  return strcmp(str1 + len1 - len2, str2) == 0;","}"],"prefix":"issuffix"},"caesar_cipher":{"body":["void caesar_cipher(char *string, int shifts)","{","  shifts = shifts % 26;","  for (int i = 0; string[i] != '\\0'; i++) {","    if (string[i] >= 'a' && string[i] <= 'z') {","      string[i] = 'a' + (string[i] - 'a' + shifts + 26) % 26;","    } else if (string[i] >= 'A' && string[i] <= 'Z') {","      string[i] = 'A' + (string[i] - 'A' + shifts + 26) % 26;","    }","  }","}"],"prefix":"caesar_cipher"},"read_string_stdin":{"body":["char *read_string(char separator)","{","  size_t capacity = 10;","  size_t length = 0;","  char *str = malloc(capacity * sizeof(char));","  if (str == NULL) {","    fprintf(stderr, \"Memory allocation failed.\\n\");","    exit(1);","  }","","  int ch;","  while ((ch = getchar()) != EOF && ch != separator && ch != '\\n') {","    str[length++] = ch;","    if (length == capacity) {","      capacity *= 2;","      str = realloc(str, capacity * sizeof(char));","      if (str == NULL) {","        fprintf(stderr, \"Memory reallocation failed.\\n\");","        exit(1);","      }","    }","  }","  str[length] = '\\0';","  return str;","}"],"prefix":"read_string_stdin"},"remove_whitespace":{"body":["void remove_whitespace(char *str)","{","  char *dst = str;","  while (*str) {","    if (!isspace((unsigned char)*str))","      *dst++ = *str;","    str++;","  }","  *dst = '\\0';","}"],"prefix":"remove_whitespace"},"longest_substring":{"prefix":"longest_substring","body":["int longest_substring(char *haystack, char *needle)","{","  int **t;","  int hstack_len, needle_len, result;","","  hstack_len = strlen(haystack), needle_len = strlen(needle);","","  t = (int **)malloc(sizeof(int *) * (hstack_len + 1));","  for (int i = 0; i <= hstack_len; ++i) {","    t[i] = (int *)malloc(sizeof(int) * (needle_len + 1));","    for (int j = 0; j <= needle_len; ++j) {","      t[i][j] = 0;","    }","  }","","  result = 0;","  for (int i = 1; i <= hstack_len; ++i) {","    for (int j = 1; j <= needle_len; ++j) {","      if (haystack[i - 1] == needle[j - 1]) {","        t[i][j] = t[i - 1][j - 1] + 1;","        result = result < t[i][j] ? t[i][j] : result;","      }","    }","  }","","  return result;","}"]},"remove_character":{"body":["void remove_character(char *str, char c)","{","  char *dst = str;","  while (*str) {","    if (*str != c)","      *dst++ = *str;","    str++;","  }","  *dst = '\\0';","}"],"prefix":"remove_character"},"fib":{"body":["int fib(int n)","{","  return n <= 1 ? n : fib(n - 1) + fib(n - 2);","}"],"prefix":"fib"},"free_lines":{"body":["void free_lines(char **lines, size_t line_count)","{","  for (size_t i = 0; i < line_count; i++) {","    free(lines[i]);","  }","  free(lines);","}"],"prefix":"free_lines"},"count_words":{"body":["int count_words()","{","  int count = 0;","  int in_word = 0;","  char c;","  while ((c = getchar()) != EOF) {","    if (isspace(c)) {","      if (in_word)","        in_word = 0;","    } else if (!in_word) {","      in_word = 1;","      count++;","    }","  }","  return count;","}"],"prefix":"count_words"},"isprime":{"body":["bool isprime(int number)","{","  if (number <= 1) return false;","  if (number <= 3) return true;","  if (number % 2 == 0 || number % 3 == 0) return false;","  for (int i = 5; i * i <= number; i += 6)","    if (number % i == 0 || number % (i + 2) == 0) return false;","  return true;","}"],"prefix":"isprime"},"libimpexp":{"body":["#ifdef _WIN32","#ifdef <LIB>_EXPORTS","#define <LIB>_API \\","  __declspec(dllexport) \/\/ when building the library, export the functions","#else","#define <LIB>_API \\","  __declspec(dllimport) \/\/ when using the library, import the functions","#endif","#else","#define <LIB>_API \\","  __attribute__((visibility(\"default\"))) \/\/ for GCC\/Clang (Linux\/Mac)","#endif"],"prefix":"libimpexp"},"read_lines":{"body":["char *line = NULL;","size_t len = 0;","size_t read;","while ((read = getline(&line, &len, stdin)) != -1) {","}"],"prefix":"read_lines"}}